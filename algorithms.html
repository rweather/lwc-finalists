<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Lightweight Cryptography Primitives: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lightweight Cryptography Primitives
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#alg_which_one">Which algorithm should I use?</a></li>
<li class="level1"><a href="#alg_properties">Summary</a></li>
<li class="level1"><a href="#alg_side_channels">Algorithms with side channel protection</a></li>
<li class="level1"><a href="#alg_ascon">ASCON</a></li>
<li class="level1"><a href="#alg_elephant">Elephant</a></li>
<li class="level1"><a href="#alg_gift_cofb">GIFT-COFB</a></li>
<li class="level1"><a href="#alg_grain_128aead">Grain-128AEAD</a></li>
<li class="level1"><a href="#alg_isap">ISAP</a></li>
<li class="level1"><a href="#alg_photon_beetle">PHOTON-Beetle</a></li>
<li class="level1"><a href="#alg_romulus">Romulus</a></li>
<li class="level1"><a href="#alg_sparkle">SPARKLE</a></li>
<li class="level1"><a href="#alg_tinyjambu">TinyJAMBU</a></li>
<li class="level1"><a href="#alg_xoodyak">Xoodyak</a></li>
<li class="level1"><a href="#alg_internal">Internal block operations</a></li>
</ul>
</div>
<div class="textblock"><p>This page lists all 10 finalists of the <a href="https://csrc.nist.gov/projects/lightweight-cryptography/round-2-candidates">NIST Lightweight Cryptography Competition</a> and the degree of support for each algorithm in the library.</p>
<h1><a class="anchor" id="alg_which_one"></a>
Which algorithm should I use?</h1>
<p>This is a tough question given that as of early-2021 the NIST competition has whittled the list down to 10 final candidates but there is still a lot of variation in the candidates. But if you want to get encrypting now:</p>
<ul>
<li><a class="el" href="algorithms.html#alg_ascon">ASCON-128</a> was already selected as a finalist for the <a href="https://competitions.cr.yp.to/caesar-submissions.html">CAESAR AEAD competition</a> (128-bit key). </li>
<li><a class="el" href="algorithms.html#alg_tinyjambu">TinyJAMBU-128</a> has exceptional performance with a small RAM and flash memory footprint (128-bit key, with options for 192-bit and 256-bit keys as well). </li>
<li><a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a> is the fastest finalist that uses a block cipher rather than a permutation. RAM usage for the default "full" variant in this library can be a bit large (320 bytes for the key schedule), but the "small" and "tiny" variants provide convenient space-vs-time tradeoffs (80 bytes and 16 bytes respectively for the key schedules).</li>
</ul>
<p>Note that these are my own personal preferences and are not based on any in-depth security analysis. The above algorithms could fall to an attack tomorrow but for now they have good space and speed trade-offs when implemented in software on 32-bit platforms.</p>
<h1><a class="anchor" id="alg_properties"></a>
Summary</h1>
<p>The following table summarises the interesting properties of the 10 finalists to the NIST Lightweight Cryptography competition. More details are provided in the sections below.</p>
<table class="doxtable">
<tr>
<td>Algorithm</td><td>Key Sizes</td><td>Core</td><td>Mode</td><td>Nonce Reuse</td><td>Side Channels</td><td>Post Quantum</td><td>Hashing </td></tr>
<tr>
<td>ASCON</td><td>128/160</td><td>ASCON</td><td>MonkeyDuplex</td><td></td><td>M</td><td>K</td><td>Digest/XOF </td></tr>
<tr>
<td>Elephant</td><td>128</td><td>Spongent/Keccak</td><td>Elephant</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>GIFT-COFB</td><td>128</td><td>GIFT-128</td><td>COFB</td><td></td><td>M</td><td></td><td></td></tr>
<tr>
<td>Grain-128AEAD</td><td>128</td><td>Grain-128</td><td>Grain-128AEAD</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>ISAP</td><td>128</td><td>ASCON/Keccak</td><td>Duplex</td><td></td><td>Y</td><td></td><td></td></tr>
<tr>
<td>PHOTON-Beetle</td><td>128</td><td>PHOTON-256</td><td>Beetle</td><td></td><td></td><td></td><td>Digest </td></tr>
<tr>
<td>Romulus-N</td><td>128</td><td>SKINNY-128-384+</td><td>Romulus-N</td><td></td><td></td><td></td><td>Digest/XOF </td></tr>
<tr>
<td>Romulus-M</td><td>128</td><td>SKINNY-128-384+</td><td>Romulus-M</td><td>Y</td><td></td><td></td><td>Digest/XOF </td></tr>
<tr>
<td>Romulus-T</td><td>128</td><td>SKINNY-128-384+</td><td>Romulus-T</td><td></td><td>Y</td><td></td><td>Digest/XOF </td></tr>
<tr>
<td>SPARKLE</td><td>128/192/256</td><td>SPARKLE</td><td>Beetle</td><td></td><td></td><td>K</td><td>Digest/XOF </td></tr>
<tr>
<td>TinyJAMBU</td><td>128/192/256</td><td>TinyJAMBU</td><td>TinyJAMBU</td><td></td><td>M</td><td>K</td><td></td></tr>
<tr>
<td>Xoodyak</td><td>128</td><td>Xoodoo</td><td>Cyclist</td><td></td><td>R</td><td></td><td>Digest/XOF </td></tr>
</table>
<p>"Core" indicates the core block operation that the sponge or block cipher mode is built around, and "Mode" indicates the mode itself.</p>
<p>All 10 finalists to the competition are inverse-free. In particular, the finalists that use block ciphers (GIFT-COFB and Romulus) only use the block encryption operation.</p>
<p>"Nonce Reuse" indicates that the algorithm provides some resistance against nonce reuse.</p>
<p>"Side Channels" indicates that the algorithm provides some resistance against power analysis side channels: "Y" indicates that the resistance is built in, "M" indicates that the resistance is present only if the core block operation is masked, and "R" indicates that the resistance is present only if the cipher is rekeyed after every packet.</p>
<p>"Post Quantum" indicates if the algorithm has resistance against post-quantum adversaries: "Y" indicates that all key sizes are resistant, "K" indicates that key sizes larger than 128 bits (e.g. 160, 192, or 256) provide the post-quantum resistance.</p>
<h1><a class="anchor" id="alg_side_channels"></a>
Algorithms with side channel protection</h1>
<p>The following algorithm implementations in this library attempt to provide some protection against power analysis side channels:</p>
<ul>
<li><a class="el" href="algorithms.html#alg_ascon">ASCON</a> </li>
<li><a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a> </li>
<li><a class="el" href="algorithms.html#alg_isap">ISAP</a> </li>
<li><a class="el" href="algorithms.html#alg_tinyjambu">TinyJAMBU</a> </li>
<li><a class="el" href="algorithms.html#alg_xoodyak">Xoodyak</a></li>
</ul>
<p>These implementations have not yet been subjected to rigorous analysis, so the level of protection may not be as great as hoped.</p>
<p>In the case of ISAP, the protection is built into the algorithm. For the others, the "individual" directory contains "*_masked" variants side by side with the original unprotected versions.</p>
<h1><a class="anchor" id="alg_ascon"></a>
ASCON</h1>
<p><b>Definition:</b> <a class="el" href="ascon-aead_8h.html">ascon-aead.h</a>, <a class="el" href="ascon-aead-masked_8h.html">ascon-aead-masked.h</a>, <a class="el" href="ascon-hash_8h.html">ascon-hash.h</a>, <a class="el" href="ascon-xof_8h_source.html">ascon-xof.h</a></p>
<p>The ASCON family consists of the following AEAD algorithms:</p>
<ul>
<li>ASCON-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>ASCON-128-a with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>ASCON-80pq with a 160-bit key, a 128-bit nonce, and a 128-bit tag.</li>
</ul>
<p>ASCON-128 is the recommended algorithm from the NIST submission. ASCON-128-a is faster but does not mix the input state quite as much as ASCON-128. ASCON-80pq is essentially the same as ASCON-128 but it has a 160-bit key which may give added resistance against quantum computers.</p>
<p>The library also implements the ASCON-HASH, ASCON-HASHA, ASCON-XOF, and ASCON-XOFA hashing algorithms as companions to the AEAD mode.</p>
<p>This library also provides a masked implementation of ASCON.</p>
<p><b>Recommendation:</b> Use ASCON-128 for now unless you consider the 128-bit key length to be too short, in which case you should use ASCON-80pq.</p>
<h1><a class="anchor" id="alg_elephant"></a>
Elephant</h1>
<p><b>Definition:</b> <a class="el" href="elephant-delirium_8h.html">elephant-delirium.h</a>, <a class="el" href="elephant-dumbo_8h.html">elephant-dumbo.h</a>, <a class="el" href="elephant-jumbo_8h.html">elephant-jumbo.h</a></p>
<p>Elephant is a family of authenticated encryption algorithms based around the Spongent-pi and Keccak permutations.</p>
<ul>
<li>Dumbo has a 128-bit key, a 96-bit nonce, and a 64-bit authentication tag. It is based around the Spongent-pi[160] permutation. </li>
<li>Jumbo has a 128-bit key, a 96-bit nonce, and a 64-bit authentication tag. It is based around the Spongent-pi[176] permutation. </li>
<li>Delirium has a 128-bit key, a 96-bit nonce, and a 128-bit authentication tag. It is based around the Keccak[200] permutation.</li>
</ul>
<p><b>Recommendation:</b> The specification recommends Dumbo.</p>
<h1><a class="anchor" id="alg_gift_cofb"></a>
GIFT-COFB</h1>
<p><b>Definition:</b> <a class="el" href="gift-cofb-aead_8h.html">gift-cofb-aead.h</a>, <a class="el" href="gift-cofb-aead-masked_8h.html">gift-cofb-aead-masked.h</a></p>
<p>GIFT-COFB is an authenticated encryption algorithm that combines the COFB (COmbined FeedBack) block cipher mode with the bit-sliced version of the GIFT-128 block cipher. The algorithm has a 128-bit key, a 128-bit nonce, and a 128-bit authentication tag.</p>
<p>The GIFT-128 block cipher was designed with hardware FPGA/ASIC implementations in mind, but with the <a href="https://eprint.iacr.org/2020/412.pdf">fixsliced</a> representation it is possible to acheive good software performance as well. This library implements fixslicing by default.</p>
<p>GIFT-COFB is a single-pass encryption algorithm, compared to the two-pass algorithm used by SUNDAE-GIFT. Out of all the GIFT-128 based submissions to NIST, GIFT-COFB has the best software performance, although HYENA is fairly close.</p>
<p>This library also implements a masked version of GIFT-COFB to provide protection against power analysis side channels.</p>
<h1><a class="anchor" id="alg_grain_128aead"></a>
Grain-128AEAD</h1>
<p><b>Definition:</b> <a class="el" href="grain-aead_8h.html">grain-aead.h</a></p>
<p>Grain-128AEAD is an authenticated encryption algorithm based around a combination of a 128-bit linear feedback shift register (LFSR) and a 128-bit non-linear feedback shift register (NFSR). It is a member of the Grain family of stream ciphers.</p>
<h1><a class="anchor" id="alg_isap"></a>
ISAP</h1>
<p><b>Definition:</b> <a class="el" href="isap-a-aead_8h.html">isap-a-aead.h</a>, <a class="el" href="isap-k-aead_8h.html">isap-k-aead.h</a></p>
<p>ISAP is a family of authenticated encryption algorithms that are built around the Keccak-p[400] or ASCON permutations. There are four algorithms in the family, each of which have a 128-bit key, a 128-bit nonce, and a 128-bit tag:</p>
<ul>
<li>ISAP-K-128A based around the Keccak-p[400] permutation with a reduced number of rounds. </li>
<li>ISAP-A-128A based around the ASCON permutation with a reduced number of rounds. </li>
<li>ISAP-K-128 based around the Keccak-p[400] permutation. </li>
<li>ISAP-A-128 based around the ASCON permutation.</li>
</ul>
<p>ISAP is designed to provide some protection against adversaries using differential power analysis to determine the key. The downside is that key setup is very slow. The Keccak-p[400] permutation is slower than ASCON on 32-bit platforms.</p>
<p><b>Recommendation:</b> The final round version of the specification recommends ISAP-A-128A. If hashing is required, then ISAP-A-128A should be paired with ASCON-HASH.</p>
<h1><a class="anchor" id="alg_photon_beetle"></a>
PHOTON-Beetle</h1>
<p><b>Definition:</b> <a class="el" href="photon-beetle-aead_8h.html">photon-beetle-aead.h</a>, <a class="el" href="photon-beetle-hash_8h.html">photon-beetle-hash.h</a></p>
<p>PHOTON-Beetle is a family of authenticated encryption algorithms based on the PHOTON-256 permutation and using the Beetle sponge mode. There are three algorithms in the family:</p>
<ul>
<li>PHOTON-Beetle-AEAD-ENC-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. Data is handled in 16 byte blocks. </li>
<li>PHOTON-Beetle-AEAD-ENC-32 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. Data is handled in 4 byte blocks. </li>
<li>PHOTON-Beetle-Hash with a 256-bit hash output. The initial data is handled as a 16 byte block, and then the remaining bytes are processed in 4 byte blocks.</li>
</ul>
<p><b>Recommendation:</b> The specification recommends PHOTON-Beetle-AEAD-ENC-128.</p>
<h1><a class="anchor" id="alg_romulus"></a>
Romulus</h1>
<p><b>Definition:</b> <a class="el" href="romulus-m-aead_8h.html">romulus-m-aead.h</a>, <a class="el" href="romulus-n-aead_8h.html">romulus-n-aead.h</a>, <a class="el" href="romulus-t-aead_8h.html">romulus-t-aead.h</a>, <a class="el" href="romulus-hash_8h.html">romulus-hash.h</a></p>
<p><b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination of the associated data (AD) and plaintext is unique.</p>
<p>Romulus is a family of authenticated encryption and hash algorithms that are built around the SKINNY-128-384+ tweakable block cipher. There are several members in the family in round 3 of the competition:</p>
<ul>
<li>Romulus-N has a 128-bit key, a 128-bit nonce, and a 128-bit tag, based around the SKINNY-128-384+ tweakable block cipher. This is the primary member of the family. </li>
<li>Romulus-M has a 128-bit key, a 128-bit nonce, and a 128-bit tag, based around the SKINNY-128-384+ tweakable block cipher. </li>
<li>Romulus-T has a 128-bit key, a 128-bit nonce, and a 128-bit tag, based around the SKINNY-128-384+ tweakable block cipher. </li>
<li>Romulus-H is a hash algorithm with a 256-bit output, based around the SKINNY-128-384+ tweakable block cipher. Romulus-H can also be extended to support XOF mode, but this library has not implemented that yet.</li>
</ul>
<p>The Romulus-M variant i resistant to nonce reuse as long as the combination of the associated data and plaintext is unique. If the same associated data and plaintext are reused under the same nonce, then the scheme will leak that the same plaintext has been sent for a second time but will not reveal the plaintext itself.</p>
<p>The Romulus-T variant is designed to provide leakage resilience.</p>
<p>The Romulus-N and Romulus-M padding and domain separation schemes are quite complex, so they are some of the larger algorithms to implement in software.</p>
<p><b>Recommendation:</b> The specification recommends Romulus-N, or Romulus-M if resistance against nonce reuse is desirable.</p>
<h1><a class="anchor" id="alg_sparkle"></a>
SPARKLE</h1>
<p><b>Definition:</b> <a class="el" href="sparkle-aead_8h.html">sparkle-aead.h</a>, <a class="el" href="sparkle-hash_8h.html">sparkle-hash.h</a></p>
<p>SPARKLE is a family of encryption and hash algorithms that are based around the SPARKLE permutation. There are three versions of the permutation with 256-bit, 384-bit, and 512-bit state sizes. The algorithms in the family are:</p>
<ul>
<li>Schwaemm256-128 with a 128-bit key, a 256-bit nonce, and a 128-bit tag. </li>
<li>Schwaemm192-192 with a 192-bit key, a 192-bit nonce, and a 192-bit tag. </li>
<li>Schwaemm128-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>Schwaemm256-256 with a 256-bit key, a 256-bit nonce, and a 256-bit tag. </li>
<li>Esch256 hash algorithm with a 256-bit digest output. </li>
<li>Esch384 hash algorithm with a 384-bit digest output. </li>
<li>XOEsch256 XOF algorithm. </li>
<li>XOEsch384 XOF algorithm.</li>
</ul>
<p>SPARKLE has good performance in software on 32-bit platforms.</p>
<p><b>Recommendation:</b> Schwaemm256-128 and Esch256 are the recommended variants from the NIST submission.</p>
<h1><a class="anchor" id="alg_tinyjambu"></a>
TinyJAMBU</h1>
<p><b>Definition:</b> <a class="el" href="tinyjambu-aead_8h.html">tinyjambu-aead.h</a>, <a class="el" href="tinyjambu-aead-masked_8h.html">tinyjambu-aead-masked.h</a></p>
<p>TinyJAMBU is a family of encryption algorithms that are built around a lightweight 128-bit permutation. There are three variants of TinyJAMBU with different key sizes:</p>
<ul>
<li>TinyJAMBU-128 with a 128-bit key, a 96-bit nonce, and a 64-bit tag. </li>
<li>TinyJAMBU-192 with a 192-bit key, a 96-bit nonce, and a 64-bit tag. </li>
<li>TinyJAMBU-256 with a 256-bit key, a 96-bit nonce, and a 64-bit tag.</li>
</ul>
<p>TinyJAMBU has one of the smallest RAM and flash memory footprints out of all of the NIST algorithms. Performance of TinyJAMBU-128 is also excellent.</p>
<p><b>Recommendation:</b> TinyJAMBU-128 is the recommended variant in the NIST submission. Use TinyJAMBU-256 if you need a greater security margin.</p>
<h1><a class="anchor" id="alg_xoodyak"></a>
Xoodyak</h1>
<p><b>Definition:</b> <a class="el" href="xoodyak-aead_8h.html">xoodyak-aead.h</a>, <a class="el" href="xoodyak-hash_8h.html">xoodyak-hash.h</a>, <a class="el" href="xoodyak-masked_8h.html">xoodyak-masked.h</a></p>
<p>Xoodyak is an authenticated encryption and hash algorithm pair based around the 384-bit Xoodoo permutation that is similar in structure to Keccak but is more efficient than Keccak on 32-bit embedded devices. The Cyclist mode of operation is used to convert the permutation into a sponge for the higher-level algorithms.</p>
<p>The Xoodyak encryption mode has a 128-bit key, a 128-bit nonce, and a 128-bit authentication tag. The Xoodyak hashing mode has a 256-bit fixed hash output and can also be used as an extensible output function (XOF).</p>
<p>The Xoodyak specification describes a re-keying mechanism where the key for one packet is used to derive the key to use on the next packet. This provides some resistance against side channel attacks by making the session key a moving target. This library does not currently implement re-keying.</p>
<p>This library also provides a masked implementation of Xoodyak.</p>
<p><b>Recommendation:</b> There is only one encryption algorithm and one hash algorithm in the Xoodyak family, so they the recommended ones.</p>
<h1><a class="anchor" id="alg_internal"></a>
Internal block operations</h1>
<p>Many of the algorithms are built on top of internal block ciphers and sponge block operations. Some of these operations are shared between multiple algorithms so they are provided in a common internal location.</p>
<p>All of the internal block operations are implemented in source files that start with the <code>internal-</code> prefix. They are not intended to be part of the public API for the AEAD algorithms.</p>
<p>If you wish to improve the performance of an algorithm implementation with assembly code or vector instructions, then the best place to start is with the internal block operation code. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 21 2021 22:08:38 for Lightweight Cryptography Primitives by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
