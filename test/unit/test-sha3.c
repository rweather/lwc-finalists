/*
 * Copyright (C) 2021 Southern Storm Software, Pty Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "test-sha3.h"
#include "test-cipher.h"
#include "internal-util.h"
#include <string.h>
#include <stdio.h>

aead_hash_algorithm_t const sha3_256_hash_algorithm = {
    "SHA3-256",
    sizeof(sha3_state_t),
    32,
    AEAD_FLAG_LITTLE_ENDIAN,
    sha3_256_hash,
    (aead_hash_init_t)sha3_256_init,
    (aead_hash_update_t)sha3_absorb,
    (aead_hash_finalize_t)sha3_squeeze,
    (aead_xof_absorb_t)sha3_absorb,
    (aead_xof_squeeze_t)sha3_squeeze
};

aead_hash_algorithm_t const sha3_512_hash_algorithm = {
    "SHA3-512",
    sizeof(sha3_state_t),
    64,
    AEAD_FLAG_LITTLE_ENDIAN,
    sha3_512_hash,
    (aead_hash_init_t)sha3_512_init,
    (aead_hash_update_t)sha3_absorb,
    (aead_hash_finalize_t)sha3_squeeze,
    (aead_xof_absorb_t)sha3_absorb,
    (aead_xof_squeeze_t)sha3_squeeze
};

aead_hash_algorithm_t const shake128_xof_algorithm = {
    "SHAKE128",
    sizeof(sha3_state_t),
    64,
    AEAD_FLAG_LITTLE_ENDIAN,
    shake128_hash,
    (aead_hash_init_t)shake128_init,
    (aead_hash_update_t)sha3_absorb,
    (aead_hash_finalize_t)sha3_squeeze,
    (aead_xof_absorb_t)sha3_absorb,
    (aead_xof_squeeze_t)sha3_squeeze
};

aead_hash_algorithm_t const shake256_xof_algorithm = {
    "SHAKE256",
    sizeof(sha3_state_t),
    64,
    AEAD_FLAG_LITTLE_ENDIAN,
    shake256_hash,
    (aead_hash_init_t)shake256_init,
    (aead_hash_update_t)sha3_absorb,
    (aead_hash_finalize_t)sha3_squeeze,
    (aead_xof_absorb_t)sha3_absorb,
    (aead_xof_squeeze_t)sha3_squeeze
};

aead_hash_algorithm_t const cshake128_xof_algorithm = {
    "cSHAKE128",
    sizeof(sha3_state_t),
    64,
    AEAD_FLAG_LITTLE_ENDIAN,
    0,
    (aead_hash_init_t)cshake128_init,
    (aead_hash_update_t)sha3_absorb,
    (aead_hash_finalize_t)sha3_squeeze,
    (aead_xof_absorb_t)sha3_absorb,
    (aead_xof_squeeze_t)sha3_squeeze
};

aead_hash_algorithm_t const cshake256_xof_algorithm = {
    "cSHAKE256",
    sizeof(sha3_state_t),
    64,
    AEAD_FLAG_LITTLE_ENDIAN,
    0,
    (aead_hash_init_t)cshake256_init,
    (aead_hash_update_t)sha3_absorb,
    (aead_hash_finalize_t)sha3_squeeze,
    (aead_xof_absorb_t)sha3_absorb,
    (aead_xof_squeeze_t)sha3_squeeze
};

void sha3_init(sha3_state_t *state, unsigned capacity, unsigned padding)
{
    memset(state->A, 0, sizeof(state->A));
    state->inputSize = 0;
    state->outputSize = 0;
    state->rate = (1600 - capacity) / 8;
    state->absorbing = 1;
    state->padding = padding;
}

void sha3_256_init(sha3_state_t *state)
{
    sha3_init(state, 512, 0x06);
}

void sha3_512_init(sha3_state_t *state)
{
    sha3_init(state, 1024, 0x06);
}

void shake128_init(sha3_state_t *state)
{
    sha3_init(state, 256, 0x1F);
}

void shake256_init(sha3_state_t *state)
{
    sha3_init(state, 512, 0x1F);
}

void cshake128_init(sha3_state_t *state)
{
    sha3_init(state, 256, 0x04);
}

void cshake256_init(sha3_state_t *state)
{
    sha3_init(state, 512, 0x04);
}

/**
 * \brief Runs the Keccak-p[1600] permutation on a SHA3 hashing state.
 *
 * \param state Points to the SHA3 state.
 */
static void sha3_keccakp(sha3_state_t *state)
{
    static uint64_t const RC[24] = {
        0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808AULL,
        0x8000000080008000ULL, 0x000000000000808BULL, 0x0000000080000001ULL,
        0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008AULL,
        0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000AULL,
        0x000000008000808BULL, 0x800000000000008BULL, 0x8000000000008089ULL,
        0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,
        0x000000000000800AULL, 0x800000008000000AULL, 0x8000000080008081ULL,
        0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
    };
    #define addMod5(x, y) (((x) + (y)) % 5)
    uint64_t B[5][5];
    uint64_t D;
    uint8_t index, index2, round;
#if !defined(LW_UTIL_LITTLE_ENDIAN)
    for (index = 0; index < 5; ++index) {
        for (index2 = 0; index2 < 5; ++index2) {
            state->A[index][index2] =
                le_load_word64((const uint8_t *)(&(state->a[index, index2])));
        }
    }
#endif
    for (round = 0; round < 24; ++round) {
        /* Step mapping theta.  The specification mentions two temporary
         * arrays of size 5 called C and D.  To save a bit of memory,
         * we use the first row of B to store C and compute D on the fly. */
        for (index = 0; index < 5; ++index) {
            B[0][index] = state->A[0][index] ^ state->A[1][index] ^
                          state->A[2][index] ^ state->A[3][index] ^
                          state->A[4][index];
        }
        for (index = 0; index < 5; ++index) {
            D = B[0][addMod5(index, 4)] ^
                leftRotate1_64(B[0][addMod5(index, 1)]);
            for (index2 = 0; index2 < 5; ++index2)
                state->A[index2][index] ^= D;
        }

        /* Step mapping rho and pi combined into a single step.
         * Rotate all lanes by a specific offset and rearrange. */
        B[0][0] = state->A[0][0];
        B[1][0] = leftRotate28_64(state->A[0][3]);
        B[2][0] = leftRotate1_64 (state->A[0][1]);
        B[3][0] = leftRotate27_64(state->A[0][4]);
        B[4][0] = leftRotate62_64(state->A[0][2]);
        B[0][1] = leftRotate44_64(state->A[1][1]);
        B[1][1] = leftRotate20_64(state->A[1][4]);
        B[2][1] = leftRotate6_64 (state->A[1][2]);
        B[3][1] = leftRotate36_64(state->A[1][0]);
        B[4][1] = leftRotate55_64(state->A[1][3]);
        B[0][2] = leftRotate43_64(state->A[2][2]);
        B[1][2] = leftRotate3_64 (state->A[2][0]);
        B[2][2] = leftRotate25_64(state->A[2][3]);
        B[3][2] = leftRotate10_64(state->A[2][1]);
        B[4][2] = leftRotate39_64(state->A[2][4]);
        B[0][3] = leftRotate21_64(state->A[3][3]);
        B[1][3] = leftRotate45_64(state->A[3][1]);
        B[2][3] = leftRotate8_64 (state->A[3][4]);
        B[3][3] = leftRotate15_64(state->A[3][2]);
        B[4][3] = leftRotate41_64(state->A[3][0]);
        B[0][4] = leftRotate14_64(state->A[4][4]);
        B[1][4] = leftRotate61_64(state->A[4][2]);
        B[2][4] = leftRotate18_64(state->A[4][0]);
        B[3][4] = leftRotate56_64(state->A[4][3]);
        B[4][4] = leftRotate2_64 (state->A[4][1]);

        /* Step mapping chi.  Combine each lane with two other lanes. */
        for (index = 0; index < 5; ++index) {
            for (index2 = 0; index2 < 5; ++index2) {
                state->A[index2][index] =
                    B[index2][index] ^
                    ((~B[index2][addMod5(index, 1)]) &
                     B[index2][addMod5(index, 2)]);
            }
        }

        // Step mapping iota.  XOR A[0][0] with the round constant.
        state->A[0][0] ^= RC[round];
    }
#if !defined(LW_UTIL_LITTLE_ENDIAN)
    for (index = 0; index < 5; ++index) {
        for (index2 = 0; index2 < 5; ++index2) {
            le_store_word64((uint8_t *)(&(state->a[index, index2])),
                            state->A[index][index2]);
        }
    }
#endif
}

void sha3_absorb
    (sha3_state_t *state, const unsigned char *data, unsigned long long size)
{
    const uint8_t *d = (const uint8_t *)data;
    uint8_t *Abytes;
    unsigned posn, len;

    /* Stop generating output while we incorporate the new data */
    state->absorbing = 1;
    state->outputSize = 0;

    /* Break the input up into chunks and process each in turn */
    while (size > 0) {
        len = state->rate - state->inputSize;
        if (len > size)
            len = size;
        Abytes = ((uint8_t *)state->A) + state->inputSize;
        for (posn = 0; posn < len; ++posn)
            Abytes[posn] ^= d[posn];
        state->inputSize += len;
        size -= len;
        d += len;
        if (state->inputSize >= state->rate) {
            sha3_keccakp(state);
            state->inputSize = 0;
        }
    }
}

void sha3_squeeze
    (sha3_state_t *state, unsigned char *data, unsigned long long size)
{
    uint8_t *d = (uint8_t *)data;
    unsigned tempSize;

    /* Stop accepting input while we are generating output */
    if (state->absorbing) {
        /* Pad the final input block */
        unsigned size = state->inputSize;
        uint64_t *Awords = &(state->A[0][0]);
        Awords[size / 8] ^= (((uint64_t)(state->padding)) << ((size % 8) * 8));
        Awords[(state->rate - 1) / 8] ^= 0x8000000000000000ULL;
        sha3_keccakp(state);
        state->inputSize = 0;
        state->outputSize = 0;
        state->absorbing = 0;
    }

    /* Copy the output data into the caller's return buffer */
    while (size > 0) {
        /* Generate another output block if the current one is exhausted */
        if (state->outputSize >= state->rate) {
            sha3_keccakp(state);
            state->outputSize = 0;
        }

        /* How many bytes can we copy this time around? */
        tempSize = state->rate - state->outputSize;
        if (tempSize > size)
            tempSize = size;

        /* Copy the partial output data into the caller's return buffer */
        memcpy(d, ((uint8_t *)(state->A)) + state->outputSize, tempSize);
        state->outputSize += tempSize;
        size -= tempSize;
        d += tempSize;
    }
}

void sha3_pad(sha3_state_t *state)
{
    state->absorbing = 1;
    state->outputSize = 0;
    if (state->inputSize != 0) {
        sha3_keccakp(state);
        state->inputSize = 0;
    }
}

int sha3_256_hash
    (unsigned char *out, const unsigned char *in, unsigned long long inlen)
{
    sha3_state_t state;
    sha3_256_init(&state);
    sha3_absorb(&state, in, inlen);
    sha3_squeeze(&state, out, 32);
    return 0;
}

int sha3_512_hash
    (unsigned char *out, const unsigned char *in, unsigned long long inlen)
{
    sha3_state_t state;
    sha3_512_init(&state);
    sha3_absorb(&state, in, inlen);
    sha3_squeeze(&state, out, 64);
    return 0;
}

int shake128_hash
    (unsigned char *out, const unsigned char *in, unsigned long long inlen)
{
    sha3_state_t state;
    shake128_init(&state);
    sha3_absorb(&state, in, inlen);
    sha3_squeeze(&state, out, 64);
    return 0;
}

int shake256_hash
    (unsigned char *out, const unsigned char *in, unsigned long long inlen)
{
    sha3_state_t state;
    shake256_init(&state);
    sha3_absorb(&state, in, inlen);
    sha3_squeeze(&state, out, 64);
    return 0;
}

/* Test cases for SHA3-256 */
static aead_hash_test_vector_t const testVectorSHA3_256_1 = {
    "SHA3-256 Test Vector 1",
    {0xA7, 0xFF, 0xC6, 0xF8, 0xBF, 0x1E, 0xD7, 0x66,
     0x51, 0xC1, 0x47, 0x56, 0xA0, 0x61, 0xD6, 0x62,
     0xF5, 0x80, 0xFF, 0x4D, 0xE4, 0x3B, 0x49, 0xFA,
     0x82, 0xD8, 0x0A, 0x4B, 0x80, 0xF8, 0x43, 0x4A},
    {0},
    0
};
static aead_hash_test_vector_t const testVectorSHA3_256_2 = {
    "SHA3-256 Test Vector 2",
    {0xBC, 0x22, 0x34, 0x5E, 0x4B, 0xD3, 0xF7, 0x92,
     0xA3, 0x41, 0xCF, 0x18, 0xAC, 0x07, 0x89, 0xF1,
     0xC9, 0xC9, 0x66, 0x71, 0x2A, 0x50, 0x1B, 0x19,
     0xD1, 0xB6, 0x63, 0x2C, 0xCD, 0x40, 0x8E, 0xC5},
    {0x1F, 0x87, 0x7C},
    3
};
static aead_hash_test_vector_t const testVectorSHA3_256_3 = {
    "SHA3-256 Test Vector 3",
    {0x2C, 0x1E, 0x61, 0xE5, 0xD4, 0x52, 0x03, 0xF2,
     0x7B, 0x86, 0xF1, 0x29, 0x3A, 0x80, 0xBA, 0xB3,
     0x41, 0x92, 0xDA, 0xF4, 0x2B, 0x86, 0x23, 0xB1,
     0x20, 0x05, 0xB2, 0xFB, 0x1C, 0x18, 0xAC, 0xB1},
    {0xE2, 0x61, 0x93, 0x98, 0x9D, 0x06, 0x56, 0x8F,
     0xE6, 0x88, 0xE7, 0x55, 0x40, 0xAE, 0xA0, 0x67,
     0x47, 0xD9, 0xF8, 0x51},
    20
};
static aead_hash_test_vector_t const testVectorSHA3_256_4 = {
    "SHA3-256 Test Vector 4",
    {0xA1, 0x9E, 0xEE, 0x92, 0xBB, 0x20, 0x97, 0xB6,
     0x4E, 0x82, 0x3D, 0x59, 0x77, 0x98, 0xAA, 0x18,
     0xBE, 0x9B, 0x7C, 0x73, 0x6B, 0x80, 0x59, 0xAB,
     0xFD, 0x67, 0x79, 0xAC, 0x35, 0xAC, 0x81, 0xB5},
    {0xB7, 0x71, 0xD5, 0xCE, 0xF5, 0xD1, 0xA4, 0x1A,
     0x93, 0xD1, 0x56, 0x43, 0xD7, 0x18, 0x1D, 0x2A,
     0x2E, 0xF0, 0xA8, 0xE8, 0x4D, 0x91, 0x81, 0x2F,
     0x20, 0xED, 0x21, 0xF1, 0x47, 0xBE, 0xF7, 0x32,
     0xBF, 0x3A, 0x60, 0xEF, 0x40, 0x67, 0xC3, 0x73,
     0x4B, 0x85, 0xBC, 0x8C, 0xD4, 0x71, 0x78, 0x0F,
     0x10, 0xDC, 0x9E, 0x82, 0x91, 0xB5, 0x83, 0x39,
     0xA6, 0x77, 0xB9, 0x60, 0x21, 0x8F, 0x71, 0xE7,
     0x93, 0xF2, 0x79, 0x7A, 0xEA, 0x34, 0x94, 0x06,
     0x51, 0x28, 0x29, 0x06, 0x5D, 0x37, 0xBB, 0x55,
     0xEA, 0x79, 0x6F, 0xA4, 0xF5, 0x6F, 0xD8, 0x89,
     0x6B, 0x49, 0xB2, 0xCD, 0x19, 0xB4, 0x32, 0x15,
     0xAD, 0x96, 0x7C, 0x71, 0x2B, 0x24, 0xE5, 0x03,
     0x2D, 0x06, 0x52, 0x32, 0xE0, 0x2C, 0x12, 0x74,
     0x09, 0xD2, 0xED, 0x41, 0x46, 0xB9, 0xD7, 0x5D,
     0x76, 0x3D, 0x52, 0xDB, 0x98, 0xD9, 0x49, 0xD3,
     0xB0, 0xFE, 0xD6, 0xA8, 0x05, 0x2F, 0xBB},
    135
};
static aead_hash_test_vector_t const testVectorSHA3_256_5 = {
    "SHA3-256 Test Vector 5",
    {0xDF, 0x67, 0x3F, 0x41, 0x05, 0x37, 0x9F, 0xF6, 
     0xB7, 0x55, 0xEE, 0xAB, 0x20, 0xCE, 0xB0, 0xDC,
     0x77, 0xB5, 0x28, 0x63, 0x64, 0xFE, 0x16, 0xC5,
     0x9C, 0xC8, 0xA9, 0x07, 0xAF, 0xF0, 0x77, 0x32},
    {0xB3, 0x2D, 0x95, 0xB0, 0xB9, 0xAA, 0xD2, 0xA8,
     0x81, 0x6D, 0xE6, 0xD0, 0x6D, 0x1F, 0x86, 0x00,
     0x85, 0x05, 0xBD, 0x8C, 0x14, 0x12, 0x4F, 0x6E,
     0x9A, 0x16, 0x3B, 0x5A, 0x2A, 0xDE, 0x55, 0xF8,
     0x35, 0xD0, 0xEC, 0x38, 0x80, 0xEF, 0x50, 0x70,
     0x0D, 0x3B, 0x25, 0xE4, 0x2C, 0xC0, 0xAF, 0x05,
     0x0C, 0xCD, 0x1B, 0xE5, 0xE5, 0x55, 0xB2, 0x30,
     0x87, 0xE0, 0x4D, 0x7B, 0xF9, 0x81, 0x36, 0x22,
     0x78, 0x0C, 0x73, 0x13, 0xA1, 0x95, 0x4F, 0x87,
     0x40, 0xB6, 0xEE, 0x2D, 0x3F, 0x71, 0xF7, 0x68,
     0xDD, 0x41, 0x7F, 0x52, 0x04, 0x82, 0xBD, 0x3A,
     0x08, 0xD4, 0xF2, 0x22, 0xB4, 0xEE, 0x9D, 0xBD,
     0x01, 0x54, 0x47, 0xB3, 0x35, 0x07, 0xDD, 0x50,
     0xF3, 0xAB, 0x42, 0x47, 0xC5, 0xDE, 0x9A, 0x8A,
     0xBD, 0x62, 0xA8, 0xDE, 0xCE, 0xA0, 0x1E, 0x3B,
     0x87, 0xC8, 0xB9, 0x27, 0xF5, 0xB0, 0x8B, 0xEB,
     0x37, 0x67, 0x4C, 0x6F, 0x8E, 0x38, 0x0C, 0x04},
    136
};

/* Test cases for SHA3-512 */
static aead_hash_test_vector_t const testVectorSHA3_512_1 = {
    "SHA3-512 Test Vector 1",
    {0xA6, 0x9F, 0x73, 0xCC, 0xA2, 0x3A, 0x9A, 0xC5,
     0xC8, 0xB5, 0x67, 0xDC, 0x18, 0x5A, 0x75, 0x6E,
     0x97, 0xC9, 0x82, 0x16, 0x4F, 0xE2, 0x58, 0x59,
     0xE0, 0xD1, 0xDC, 0xC1, 0x47, 0x5C, 0x80, 0xA6,
     0x15, 0xB2, 0x12, 0x3A, 0xF1, 0xF5, 0xF9, 0x4C,
     0x11, 0xE3, 0xE9, 0x40, 0x2C, 0x3A, 0xC5, 0x58,
     0xF5, 0x00, 0x19, 0x9D, 0x95, 0xB6, 0xD3, 0xE3,
     0x01, 0x75, 0x85, 0x86, 0x28, 0x1D, 0xCD, 0x26},
    {0},
    0
};
static aead_hash_test_vector_t const testVectorSHA3_512_2 = {
    "SHA3-512 Test Vector 2",
    {0xCB, 0x20, 0xDC, 0xF5, 0x49, 0x55, 0xF8, 0x09,
     0x11, 0x11, 0x68, 0x8B, 0xEC, 0xCE, 0xF4, 0x8C,
     0x1A, 0x2F, 0x0D, 0x06, 0x08, 0xC3, 0xA5, 0x75,
     0x16, 0x37, 0x51, 0xF0, 0x02, 0xDB, 0x30, 0xF4,
     0x0F, 0x2F, 0x67, 0x18, 0x34, 0xB2, 0x2D, 0x20,
     0x85, 0x91, 0xCF, 0xAF, 0x1F, 0x5E, 0xCF, 0xE4,
     0x3C, 0x49, 0x86, 0x3A, 0x53, 0xB3, 0x22, 0x5B,
     0xDF, 0xD7, 0xC6, 0x59, 0x1B, 0xA7, 0x65, 0x8B},
    {0x1F, 0x87, 0x7C},
    3
};
static aead_hash_test_vector_t const testVectorSHA3_512_3 = {
    "SHA3-512 Test Vector 3",
    {0x19, 0x1C, 0xEF, 0x1C, 0x6A, 0xA0, 0x09, 0xB1,
     0xAB, 0xA6, 0x74, 0xBE, 0x2B, 0x3F, 0x0D, 0xA4,
     0x18, 0xFD, 0xF9, 0xE6, 0xA7, 0xEC, 0xF2, 0xBE,
     0x42, 0xAC, 0x14, 0xF7, 0xD6, 0xE0, 0x73, 0x31,
     0x42, 0x51, 0x33, 0xA8, 0x3B, 0x4E, 0x01, 0x61,
     0xCC, 0x7D, 0xEB, 0xF9, 0xDC, 0xD7, 0xFE, 0x37,
     0x87, 0xDC, 0xB6, 0x62, 0x2A, 0x38, 0x47, 0x51,
     0x89, 0xED, 0xFE, 0x1D, 0xE6, 0xB0, 0x53, 0xD6},
    {0xE2, 0x61, 0x93, 0x98, 0x9D, 0x06, 0x56, 0x8F,
     0xE6, 0x88, 0xE7, 0x55, 0x40, 0xAE, 0xA0, 0x67,
     0x47, 0xD9, 0xF8, 0x51},
    20
};
static aead_hash_test_vector_t const testVectorSHA3_512_4 = {
    "SHA3-512 Test Vector 4",
    {0xDE, 0xF4, 0xAB, 0x6C, 0xDA, 0x88, 0x39, 0x72,
     0x9A, 0x03, 0xE0, 0x00, 0x84, 0x66, 0x04, 0xB1,
     0x7F, 0x03, 0xC5, 0xD5, 0xD7, 0xEC, 0x23, 0xC4,
     0x83, 0x67, 0x0A, 0x13, 0xE1, 0x15, 0x73, 0xC1,
     0xE9, 0x34, 0x7A, 0x63, 0xEC, 0x69, 0xA5, 0xAB,
     0xB2, 0x13, 0x05, 0xF9, 0x38, 0x2E, 0xCD, 0xAA,
     0xAB, 0xC6, 0x85, 0x0F, 0x92, 0x84, 0x0E, 0x86,
     0xF8, 0x8F, 0x4D, 0xAB, 0xFC, 0xD9, 0x3C, 0xC0},
    {0x13, 0xBD, 0x28, 0x11, 0xF6, 0xED, 0x2B, 0x6F,
     0x04, 0xFF, 0x38, 0x95, 0xAC, 0xEE, 0xD7, 0xBE,
     0xF8, 0xDC, 0xD4, 0x5E, 0xB1, 0x21, 0x79, 0x1B,
     0xC1, 0x94, 0xA0, 0xF8, 0x06, 0x20, 0x6B, 0xFF,
     0xC3, 0xB9, 0x28, 0x1C, 0x2B, 0x30, 0x8B, 0x1A,
     0x72, 0x9C, 0xE0, 0x08, 0x11, 0x9D, 0xD3, 0x06,
     0x6E, 0x93, 0x78, 0xAC, 0xDC, 0xC5, 0x0A, 0x98,
     0xA8, 0x2E, 0x20, 0x73, 0x88, 0x00, 0xB6, 0xCD,
     0xDB, 0xE5, 0xFE, 0x96, 0x94, 0xAD, 0x6D},
    71
};
static aead_hash_test_vector_t const testVectorSHA3_512_5 = {
    "SHA3-512 Test Vector 5",
    {0xA3, 0xE1, 0x68, 0xB0, 0xD6, 0xC1, 0x43, 0xEE,
     0x9E, 0x17, 0xEA, 0xE9, 0x29, 0x30, 0xB9, 0x7E,
     0x66, 0x00, 0x35, 0x6B, 0x73, 0xAE, 0xBB, 0x5D,
     0x68, 0x00, 0x5D, 0xD1, 0xD0, 0x74, 0x94, 0x45,
     0x1A, 0x37, 0x05, 0x2F, 0x7B, 0x39, 0xFF, 0x03,
     0x0C, 0x1A, 0xE1, 0xD7, 0xEF, 0xC4, 0xE0, 0xC3,
     0x66, 0x7E, 0xB7, 0xA7, 0x6C, 0x62, 0x7E, 0xC1,
     0x43, 0x54, 0xC4, 0xF6, 0xA7, 0x96, 0xE2, 0xC6},
    {0x1E, 0xED, 0x9C, 0xBA, 0x17, 0x9A, 0x00, 0x9E,
     0xC2, 0xEC, 0x55, 0x08, 0x77, 0x3D, 0xD3, 0x05,
     0x47, 0x7C, 0xA1, 0x17, 0xE6, 0xD5, 0x69, 0xE6,
     0x6B, 0x5F, 0x64, 0xC6, 0xBC, 0x64, 0x80, 0x1C,
     0xE2, 0x5A, 0x84, 0x24, 0xCE, 0x4A, 0x26, 0xD5,
     0x75, 0xB8, 0xA6, 0xFB, 0x10, 0xEA, 0xD3, 0xFD,
     0x19, 0x92, 0xED, 0xDD, 0xEE, 0xC2, 0xEB, 0xE7,
     0x15, 0x0D, 0xC9, 0x8F, 0x63, 0xAD, 0xC3, 0x23,
     0x7E, 0xF5, 0x7B, 0x91, 0x39, 0x7A, 0xA8, 0xA7},
    72
};

/* Test cases for SHAKE128 */
static aead_hash_test_vector_t const testVectorSHAKE128_1 = {
    "SHAKE128 Test Vector 1",
    {0x7F, 0x9C, 0x2B, 0xA4, 0xE8, 0x8F, 0x82, 0x7D,
     0x61, 0x60, 0x45, 0x50, 0x76, 0x05, 0x85, 0x3E,
     0xD7, 0x3B, 0x80, 0x93, 0xF6, 0xEF, 0xBC, 0x88,
     0xEB, 0x1A, 0x6E, 0xAC, 0xFA, 0x66, 0xEF, 0x26,
     0x3C, 0xB1, 0xEE, 0xA9, 0x88, 0x00, 0x4B, 0x93,
     0x10, 0x3C, 0xFB, 0x0A, 0xEE, 0xFD, 0x2A, 0x68,
     0x6E, 0x01, 0xFA, 0x4A, 0x58, 0xE8, 0xA3, 0x63,
     0x9C, 0xA8, 0xA1, 0xE3, 0xF9, 0xAE, 0x57, 0xE2},
    {0},
    0,
};
static aead_hash_test_vector_t const testVectorSHAKE128_2 = {
    "SHAKE128 Test Vector 2",
    {0xE2, 0xD3, 0x14, 0x46, 0x69, 0xAB, 0x57, 0x83,
     0x47, 0xFC, 0xCA, 0x0B, 0x57, 0x27, 0x83, 0xA2,
     0x69, 0xA8, 0xCF, 0x9A, 0xDD, 0xA4, 0xD8, 0x77,
     0x82, 0x05, 0x3D, 0x80, 0xD5, 0xF0, 0xFD, 0xD2,
     0x78, 0x35, 0xCF, 0x88, 0x30, 0x36, 0xE5, 0x36,
     0xCE, 0x76, 0xFE, 0xF6, 0x89, 0xA5, 0xE7, 0xBD,
     0x64, 0x6A, 0x7F, 0xB7, 0xD7, 0x4F, 0x09, 0x01,
     0x93, 0xB2, 0x39, 0x0E, 0x61, 0x47, 0x59, 0xB7},
    {0x1F, 0x87, 0x7C},
    3,
};
static aead_hash_test_vector_t const testVectorSHAKE128_3 = {
    "SHAKE128 Test Vector 3",
    {0xC7, 0x3D, 0x8F, 0xAA, 0xB5, 0xD0, 0xB4, 0xD6,
     0x60, 0xBD, 0x50, 0x82, 0xE4, 0x4C, 0x3C, 0xAC,
     0x97, 0xE6, 0x16, 0x48, 0xBE, 0x0A, 0x04, 0xB1,
     0x16, 0x72, 0x4E, 0x6F, 0x6B, 0x65, 0x76, 0x84,
     0x67, 0x4B, 0x4B, 0x0E, 0x90, 0xD0, 0xAE, 0x96,
     0xC0, 0x85, 0x3E, 0xBD, 0x83, 0x7B, 0xD8, 0x24,
     0x9A, 0xDB, 0xD3, 0xB6, 0x0A, 0x1A, 0xD1, 0xFC,
     0xF8, 0xA6, 0xAB, 0x8E, 0x2F, 0x5A, 0xA7, 0xFF},
    {0x0D, 0x8D, 0x09, 0xAE, 0xD1, 0x9F, 0x10, 0x13,
     0x96, 0x9C, 0xE5, 0xE7, 0xEB, 0x92, 0xF8, 0x3A,
     0x20, 0x9A, 0xE7, 0x6B, 0xE3, 0x1C, 0x75, 0x48,
     0x44, 0xEA, 0x91, 0x16, 0xCE, 0xB3, 0x9A, 0x22,
     0xEB, 0xB6, 0x00, 0x30, 0x17, 0xBB, 0xCF, 0x26,
     0x55, 0x5F, 0xA6, 0x62, 0x41, 0x85, 0x18, 0x7D,
     0xB8, 0xF0, 0xCB, 0x35, 0x64, 0xB8, 0xB1, 0xC0,
     0x6B, 0xF6, 0x85, 0xD4, 0x7F, 0x32, 0x86, 0xED,
     0xA2, 0x0B, 0x83, 0x35, 0x8F, 0x59, 0x9D, 0x20,
     0x44, 0xBB, 0xF0, 0x58, 0x3F, 0xAB, 0x8D, 0x78,
     0xF8, 0x54, 0xFE, 0x0A, 0x59, 0x61, 0x83, 0x23,
     0x0C, 0x5E, 0xF8, 0xE5, 0x44, 0x26, 0x75, 0x0E,
     0xAF, 0x2C, 0xC4, 0xE2, 0x9D, 0x3B, 0xDD, 0x03,
     0x7E, 0x73, 0x4D, 0x86, 0x3C, 0x2B, 0xD9, 0x78,
     0x9B, 0x4C, 0x24, 0x30, 0x96, 0x13, 0x8F, 0x76,
     0x72, 0xC2, 0x32, 0x31, 0x4E, 0xFF, 0xDF, 0xC6,
     0x51, 0x34, 0x27, 0xE2, 0xDA, 0x76, 0x91, 0x6B,
     0x52, 0x48, 0x93, 0x3B, 0xE3, 0x12, 0xEB, 0x5D,
     0xDE, 0x4C, 0xF7, 0x08, 0x04, 0xFB, 0x25, 0x8A,
     0xC5, 0xFB, 0x82, 0xD5, 0x8D, 0x08, 0x17, 0x7A,
     0xC6, 0xF4, 0x75, 0x60, 0x17, 0xFF, 0xF5},
    167,
};

/* Test cases for SHAKE256 */
static aead_hash_test_vector_t const testVectorSHAKE256_1 = {
    "SHAKE256 Test Vector 1",
    {0x46, 0xB9, 0xDD, 0x2B, 0x0B, 0xA8, 0x8D, 0x13,
     0x23, 0x3B, 0x3F, 0xEB, 0x74, 0x3E, 0xEB, 0x24,
     0x3F, 0xCD, 0x52, 0xEA, 0x62, 0xB8, 0x1B, 0x82,
     0xB5, 0x0C, 0x27, 0x64, 0x6E, 0xD5, 0x76, 0x2F,
     0xD7, 0x5D, 0xC4, 0xDD, 0xD8, 0xC0, 0xF2, 0x00,
     0xCB, 0x05, 0x01, 0x9D, 0x67, 0xB5, 0x92, 0xF6,
     0xFC, 0x82, 0x1C, 0x49, 0x47, 0x9A, 0xB4, 0x86,
     0x40, 0x29, 0x2E, 0xAC, 0xB3, 0xB7, 0xC4, 0xBE},
    {0},
    0,
};
static aead_hash_test_vector_t const testVectorSHAKE256_2 = {
    "SHAKE256 Test Vector 2",
    {0xF6, 0xBF, 0x03, 0x97, 0xDB, 0xFB, 0xB2, 0x0E,
     0x4A, 0xE3, 0x0F, 0x0A, 0x47, 0xFE, 0x97, 0x6C,
     0xD1, 0x09, 0xB3, 0xAA, 0x09, 0xB0, 0xE3, 0xF2,
     0x9F, 0x56, 0x0E, 0x4E, 0xD3, 0x33, 0xC0, 0xD0,
     0x83, 0x32, 0x6B, 0x03, 0xF6, 0xEA, 0xEB, 0x57,
     0xE2, 0x77, 0xBB, 0xFE, 0x1C, 0xCE, 0x36, 0xC4,
     0x99, 0x43, 0x4D, 0x83, 0x8C, 0xB4, 0xC8, 0xCD,
     0x8B, 0x02, 0xA8, 0x77, 0x90, 0xF4, 0xA6, 0x71},
    {0x1F, 0x87, 0x7C},
    3,
};
static aead_hash_test_vector_t const testVectorSHAKE256_3 = {
    "SHAKE256 Test Vector 3",
    {0x6C, 0x60, 0x95, 0x5D, 0xCB, 0x8A, 0x66, 0x3B,
     0x6D, 0xC7, 0xF5, 0xEF, 0x7E, 0x06, 0x9C, 0xA8,
     0xFE, 0x3D, 0xA9, 0x9A, 0x66, 0xDF, 0x65, 0x96,
     0x92, 0x5D, 0x55, 0x7F, 0xED, 0x91, 0xF4, 0x70,
     0x91, 0x40, 0x7D, 0x6F, 0xDE, 0x32, 0x02, 0x3B,
     0x57, 0xE2, 0xEE, 0x4C, 0x6A, 0xC9, 0x7B, 0x07,
     0x76, 0x24, 0xFA, 0xC2, 0x5F, 0x6E, 0x13, 0xF4,
     0x19, 0x16, 0x96, 0xB4, 0x0A, 0x4D, 0xF7, 0x5F},
    {0xB7, 0x71, 0xD5, 0xCE, 0xF5, 0xD1, 0xA4, 0x1A,
     0x93, 0xD1, 0x56, 0x43, 0xD7, 0x18, 0x1D, 0x2A,
     0x2E, 0xF0, 0xA8, 0xE8, 0x4D, 0x91, 0x81, 0x2F,
     0x20, 0xED, 0x21, 0xF1, 0x47, 0xBE, 0xF7, 0x32,
     0xBF, 0x3A, 0x60, 0xEF, 0x40, 0x67, 0xC3, 0x73,
     0x4B, 0x85, 0xBC, 0x8C, 0xD4, 0x71, 0x78, 0x0F,
     0x10, 0xDC, 0x9E, 0x82, 0x91, 0xB5, 0x83, 0x39,
     0xA6, 0x77, 0xB9, 0x60, 0x21, 0x8F, 0x71, 0xE7,
     0x93, 0xF2, 0x79, 0x7A, 0xEA, 0x34, 0x94, 0x06,
     0x51, 0x28, 0x29, 0x06, 0x5D, 0x37, 0xBB, 0x55,
     0xEA, 0x79, 0x6F, 0xA4, 0xF5, 0x6F, 0xD8, 0x89,
     0x6B, 0x49, 0xB2, 0xCD, 0x19, 0xB4, 0x32, 0x15,
     0xAD, 0x96, 0x7C, 0x71, 0x2B, 0x24, 0xE5, 0x03,
     0x2D, 0x06, 0x52, 0x32, 0xE0, 0x2C, 0x12, 0x74,
     0x09, 0xD2, 0xED, 0x41, 0x46, 0xB9, 0xD7, 0x5D,
     0x76, 0x3D, 0x52, 0xDB, 0x98, 0xD9, 0x49, 0xD3,
     0xB0, 0xFE, 0xD6, 0xA8, 0x05, 0x2F, 0xBB},
    135
};

void test_sha3(void)
{
    test_hash_start(&sha3_256_hash_algorithm);
    test_hash(&sha3_256_hash_algorithm, &testVectorSHA3_256_1);
    test_hash(&sha3_256_hash_algorithm, &testVectorSHA3_256_2);
    test_hash(&sha3_256_hash_algorithm, &testVectorSHA3_256_3);
    test_hash(&sha3_256_hash_algorithm, &testVectorSHA3_256_4);
    test_hash(&sha3_256_hash_algorithm, &testVectorSHA3_256_5);
    test_hash_end(&sha3_256_hash_algorithm);

    test_hash_start(&sha3_512_hash_algorithm);
    test_hash(&sha3_512_hash_algorithm, &testVectorSHA3_512_1);
    test_hash(&sha3_512_hash_algorithm, &testVectorSHA3_512_2);
    test_hash(&sha3_512_hash_algorithm, &testVectorSHA3_512_3);
    test_hash(&sha3_512_hash_algorithm, &testVectorSHA3_512_4);
    test_hash(&sha3_512_hash_algorithm, &testVectorSHA3_512_5);
    test_hash_end(&sha3_512_hash_algorithm);

    test_hash_start(&shake128_xof_algorithm);
    test_hash(&shake128_xof_algorithm, &testVectorSHAKE128_1);
    test_hash(&shake128_xof_algorithm, &testVectorSHAKE128_2);
    test_hash(&shake128_xof_algorithm, &testVectorSHAKE128_3);
    test_hash_end(&shake128_xof_algorithm);

    test_hash_start(&shake256_xof_algorithm);
    test_hash(&shake256_xof_algorithm, &testVectorSHAKE256_1);
    test_hash(&shake256_xof_algorithm, &testVectorSHAKE256_2);
    test_hash(&shake256_xof_algorithm, &testVectorSHAKE256_3);
    test_hash_end(&shake256_xof_algorithm);
}
